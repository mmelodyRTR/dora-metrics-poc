name: Fake Deploy (POC)

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Version / tag to deploy (e.g. v1.2.3)"
        required: true
        type: string

permissions:
  contents: write

env:
  DEPLOYED_VERSION_FILE: .deployment/deployed_version.txt
  SERVICE_NAME: poc-service
  ENVIRONMENT: production

jobs:
  fake-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          
      - name: Validate GitHub Release exists
        run: |
          TAG="${{ inputs.release_tag }}"
          echo "Validating GitHub Release for tag: $TAG"

          # This will exit non-zero if the release doesn't exist
          if ! gh release view "$TAG" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
            echo "âŒ No GitHub Release found for tag '$TAG'"
            exit 1
          fi

          echo "âœ… Found GitHub Release for tag '$TAG'"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Ensure deployment state directory exists
        run: |
          mkdir -p "$(dirname "${DEPLOYED_VERSION_FILE}")"

      - name: Read previously deployed version
        id: previous
        run: |
          if [ -f "${DEPLOYED_VERSION_FILE}" ]; then
            PREV_VERSION=$(cat "${DEPLOYED_VERSION_FILE}")
            echo "Previously deployed version: ${PREV_VERSION}"
          else
            PREV_VERSION=""
            echo "No previously deployed version found (first deploy)."
          fi

          echo "previous_version=${PREV_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Fake deploy
        run: |
          CURRENT_VERSION="${{ inputs.release_tag }}"
          echo "ðŸš€ Fake deploying version: ${CURRENT_VERSION}"
          echo "â„¹ï¸ Previous version was: ${{ steps.previous.outputs.previous_version }}"

          # here is where you'd call Helm / kubectl in a real workflow
          # for now we just echo
          echo "Pretending to roll out ${CURRENT_VERSION} to our 'cluster'"

      - name: Write newly deployed version to file
        run: |
          CURRENT_VERSION="${{ inputs.release_tag }}"
          echo "${CURRENT_VERSION}" > "${DEPLOYED_VERSION_FILE}"
          echo "Wrote deployed version '${CURRENT_VERSION}' to ${DEPLOYED_VERSION_FILE}"

      - name: Commit and push deployment state
        run: |
          # Only commit if there are changes (e.g. version actually changed or first run)
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

            git add "${DEPLOYED_VERSION_FILE}"
            git commit -m "Fake deploy: set deployed version to ${{ inputs.release_tag }}"
            git push
            echo "Pushed updated deployed version to repository."
          else
            echo "No changes to commit."
          fi

      - name: Show final state (for debugging)
        run: |
          echo "===== Deployment state file ====="
          cat "${DEPLOYED_VERSION_FILE}"
          echo "================================="
          echo "Previous version: ${{ steps.previous.outputs.previous_version }}"
          echo "Current version : ${{ inputs.release_tag }}"

      - name: Calculate DORA-style metrics (deploy + rollback + lead time)
        uses: actions/github-script@v7
        env:
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          ENVIRONMENT: ${{ inputs.environment }}
          CURRENT_TAG: ${{ inputs.release_tag }}
          PREVIOUS_TAG: ${{ steps.previous.outputs.previous_version }}
          with:
            script: |
              const service = process.env.SERVICE_NAME;
              const envName = process.env.ENVIRONMENT;
              const currentTag = process.env.CURRENT_TAG;
              const previousTag = process.env.PREVIOUS_TAG;
  
              core.info(`Service: ${service}`);
              core.info(`Environment: ${envName}`);
              core.info(`Current tag: ${currentTag}`);
              core.info(`Previous tag: ${previousTag || '<none>'}`);
  
              // --- Simple semver comparison helpers ---
              function parseSemver(tag) {
                if (!tag) return null;
                const clean = tag.replace(/^v/, '');
                const parts = clean.split('.');
                if (parts.length < 3) return null;
                return {
                  major: Number(parts[0]),
                  minor: Number(parts[1]),
                  patch: Number(parts[2]),
                };
              }
  
              function isRollback(current, previous) {
                const c = parseSemver(current);
                const p = parseSemver(previous);
                if (!c || !p) return false;
                if (c.major !== p.major) return c.major < p.major;
                if (c.minor !== p.minor) return c.minor < p.minor;
                return c.patch < p.patch;
              }
  
              const rollback = previousTag ? isRollback(currentTag, previousTag) : false;
              core.setOutput('rollback', rollback ? 'true' : 'false');
  
              // ------------------
              // Deployment Metric (log only)
              // ------------------
              core.info('--- Deployment metric (POC) ---');
              core.info(
                `METRIC deployment_total{service="${service}",env="${envName}",from="${previousTag || ''}",to="${currentTag}",rollback="${rollback}"} 1`
              );
  
              if (!previousTag) {
                core.info('No previous tag; skipping lead-time calculation.');
                core.setOutput('prs_json', '[]');
                core.setOutput('merge_lead_time_p50', '');
                core.setOutput('merge_lead_time_avg', '');
                core.setOutput('merge_lead_time_p90', '');
                core.setOutput('first_commit_lead_time_p50', '');
                core.setOutput('first_commit_lead_time_avg', '');
                core.setOutput('first_commit_lead_time_p90', '');
                return;
              }
  
              const owner = context.repo.owner;
              const repo = context.repo.repo;
  
              const prevRef = previousTag;
              const currRef = currentTag;
  
              core.info(`Fetching commits between ${prevRef}...${currRef}`);
  
              const compare = await github.rest.repos.compareCommitsWithBasehead({
                owner,
                repo,
                basehead: `${prevRef}...${currRef}`,
              });
  
              const commits = compare.data.commits ?? [];
              core.info(`Found ${commits.length} commits in diff.`);
  
              const deployTime = new Date();
              const mergeTimes = [];
              const firstCommitTimes = [];
              const prMetrics = [];
              const seenPrs = new Set();
  
              for (const commit of commits) {
                const sha = commit.sha;
  
                const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: sha,
                });
  
                for (const pr of prs.data) {
                  if (!pr.merged_at) continue;
                  if (seenPrs.has(pr.number)) continue;
                  seenPrs.add(pr.number);
  
                  const mergedAt = new Date(pr.merged_at);
                  const mergeLeadSeconds = Math.round(
                    (deployTime.getTime() - mergedAt.getTime()) / 1000
                  );
                  mergeTimes.push(mergeLeadSeconds);
  
                  // First-commit-in-PR â†’ deploy
                  const prCommits = await github.rest.pulls.listCommits({
                    owner,
                    repo,
                    pull_number: pr.number,
                    per_page: 100,
                  });
  
                  let earliestCommitTime = null;
                  for (const c of prCommits.data) {
                    const authorDate = c.commit?.author?.date;
                    const committerDate = c.commit?.committer?.date;
                    const candidate = authorDate || committerDate;
                    if (!candidate) continue;
                    const t = new Date(candidate);
                    if (!earliestCommitTime || t < earliestCommitTime) {
                      earliestCommitTime = t;
                    }
                  }
  
                  let firstCommitLeadSeconds = null;
                  if (earliestCommitTime) {
                    firstCommitLeadSeconds = Math.round(
                      (deployTime.getTime() - earliestCommitTime.getTime()) / 1000
                    );
                    firstCommitTimes.push(firstCommitLeadSeconds);
                  }
  
                  prMetrics.push({
                    number: pr.number,
                    title: pr.title,
                    merge_lead_time_seconds: mergeLeadSeconds,
                    first_commit_lead_time_seconds: firstCommitLeadSeconds,
                  });
  
                  core.info(
                    `PR #${pr.number}: merge_lead=${mergeLeadSeconds}s` +
                    (firstCommitLeadSeconds != null
                      ? `, first_commit_lead=${firstCommitLeadSeconds}s`
                      : '')
                  );
                }
              }
  
              core.setOutput('prs_json', JSON.stringify(prMetrics));
  
              function stats(arr) {
                if (!arr.length) return { p50: null, p90: null, avg: null };
                const sorted = [...arr].sort((a, b) => a - b);
                const p50 = sorted[Math.floor(0.5 * (sorted.length - 1))];
                const p90 = sorted[Math.floor(0.9 * (sorted.length - 1))];
                const avg = Math.round(sorted.reduce((a, b) => a + b, 0) / sorted.length);
                return { p50, p90, avg };
              }
  
              const mergeStats = stats(mergeTimes);
              const firstStats = stats(firstCommitTimes);
  
              // Set outputs for summary
              core.setOutput('merge_lead_time_p50', mergeStats.p50 ?? '');
              core.setOutput('merge_lead_time_avg', mergeStats.avg ?? '');
              core.setOutput('merge_lead_time_p90', mergeStats.p90 ?? '');
              core.setOutput('first_commit_lead_time_p50', firstStats.p50 ?? '');
              core.setOutput('first_commit_lead_time_avg', firstStats.avg ?? '');
              core.setOutput('first_commit_lead_time_p90', firstStats.p90 ?? '');
  
              core.info('Lead time (merge â†’ deploy) stats: ' +
                `p50=${mergeStats.p50}, avg=${mergeStats.avg}, p90=${mergeStats.p90}`);
              core.info('Lead time (first commit â†’ deploy) stats: ' +
                `p50=${firstStats.p50}, avg=${firstStats.avg}, p90=${firstStats.p90}`);
      - name: DORA metrics summary
        run: |
          echo "## DORA Metrics Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          echo "**Rollback:** \`${{ steps.dora_metrics.outputs.rollback }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          echo "### Aggregate lead times (seconds)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Type | p50 | avg | p90 |" >> "$GITHUB_STEP_SUMMARY"
          echo "|------|-----|-----|-----|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Merge â†’ Deploy | ${{ steps.dora_metrics.outputs.merge_lead_time_p50 }} | ${{ steps.dora_metrics.outputs.merge_lead_time_avg }} | ${{ steps.dora_metrics.outputs.merge_lead_time_p90 }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| First Commit â†’ Deploy | ${{ steps.dora_metrics.outputs.first_commit_lead_time_p50 }} | ${{ steps.dora_metrics.outputs.first_commit_lead_time_avg }} | ${{ steps.dora_metrics.outputs.first_commit_lead_time_p90 }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          echo "### Per-PR lead times" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          PRS_JSON='${{ steps.dora_metrics.outputs.prs_json }}'
          echo "$PRS_JSON" | jq -r '
            (["PR", "Title", "Mergeâ†’Deploy (s)", "FirstCommitâ†’Deploy (s)"] | @tsv),
            (.[] | [("#" + (.number|tostring)), .title, (.merge_lead_time_seconds|tostring), (if .first_commit_lead_time_seconds == null then "" else (.first_commit_lead_time_seconds|tostring) end)] | @tsv)
          ' | tr '\t' '|' | while IFS= read -r line; do
            if [[ "$line" == PR* ]]; then
              echo "| $line |" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "| $line |" >> "$GITHUB_STEP_SUMMARY"
            fi
          done
        shell: bash

