name: Fake Deploy (POC)

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Version / tag to deploy (e.g. v1.2.3)"
        required: true
        type: string

permissions:
  contents: write

env:
  DEPLOYED_VERSION_FILE: .deployment/deployed_version.txt
  SERVICE_NAME: poc-service
  ENVIRONMENT: production

jobs:
  fake-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          
      - name: Validate GitHub Release exists
        run: |
          TAG="${{ inputs.release_tag }}"
          echo "Validating GitHub Release for tag: $TAG"

          # This will exit non-zero if the release doesn't exist
          if ! gh release view "$TAG" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
            echo "âŒ No GitHub Release found for tag '$TAG'"
            exit 1
          fi

          echo "âœ… Found GitHub Release for tag '$TAG'"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Ensure deployment state directory exists
        run: |
          mkdir -p "$(dirname "${DEPLOYED_VERSION_FILE}")"

      - name: Read previously deployed version
        id: previous
        run: |
          if [ -f "${DEPLOYED_VERSION_FILE}" ]; then
            PREV_VERSION=$(cat "${DEPLOYED_VERSION_FILE}")
            echo "Previously deployed version: ${PREV_VERSION}"
          else
            PREV_VERSION=""
            echo "No previously deployed version found (first deploy)."
          fi

          echo "previous_version=${PREV_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Fake deploy
        run: |
          CURRENT_VERSION="${{ inputs.release_tag }}"
          echo "ðŸš€ Fake deploying version: ${CURRENT_VERSION}"
          echo "â„¹ï¸ Previous version was: ${{ steps.previous.outputs.previous_version }}"

          # here is where you'd call Helm / kubectl in a real workflow
          # for now we just echo
          echo "Pretending to roll out ${CURRENT_VERSION} to our 'cluster'"

      - name: Write newly deployed version to file
        run: |
          CURRENT_VERSION="${{ inputs.release_tag }}"
          echo "${CURRENT_VERSION}" > "${DEPLOYED_VERSION_FILE}"
          echo "Wrote deployed version '${CURRENT_VERSION}' to ${DEPLOYED_VERSION_FILE}"

      - name: Commit and push deployment state
        run: |
          # Only commit if there are changes (e.g. version actually changed or first run)
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

            git add "${DEPLOYED_VERSION_FILE}"
            git commit -m "Fake deploy: set deployed version to ${{ inputs.release_tag }}"
            git push
            echo "Pushed updated deployed version to repository."
          else
            echo "No changes to commit."
          fi

      - name: Show final state (for debugging)
        run: |
          echo "===== Deployment state file ====="
          cat "${DEPLOYED_VERSION_FILE}"
          echo "================================="
          echo "Previous version: ${{ steps.previous.outputs.previous_version }}"
          echo "Current version : ${{ inputs.release_tag }}"

      - name: Calculate DORA-style metrics (deploy + rollback + lead time)
        uses: actions/github-script@v7
        env:
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          ENVIRONMENT: ${{ inputs.environment }}
          CURRENT_TAG: ${{ inputs.release_tag }}
          PREVIOUS_TAG: ${{ steps.previous.outputs.previous_version }}
        with:
          script: |
            const service = process.env.SERVICE_NAME;
            const envName = process.env.ENVIRONMENT;
            const currentTag = process.env.CURRENT_TAG;
            const previousTag = process.env.PREVIOUS_TAG;

            core.info(`Service: ${service}`);
            core.info(`Environment: ${envName}`);
            core.info(`Current tag: ${currentTag}`);
            core.info(`Previous tag: ${previousTag || '<none>'}`);

            // --- Simple semver comparison helpers ---
            function parseSemver(tag) {
              if (!tag) return null;
              const clean = tag.replace(/^v/, '');
              const parts = clean.split('.');
              if (parts.length < 3) return null;
              return {
                major: Number(parts[0]),
                minor: Number(parts[1]),
                patch: Number(parts[2]),
              };
            }

            function isRollback(current, previous) {
              const c = parseSemver(current);
              const p = parseSemver(previous);
              if (!c || !p) return false;
              if (c.major !== p.major) return c.major < p.major;
              if (c.minor !== p.minor) return c.minor < p.minor;
              return c.patch < p.patch;
            }

            const rollback = previousTag ? isRollback(currentTag, previousTag) : false;

            // ------------------
            // Deployment Metric
            // ------------------
            core.info('--- Deployment metric (POC) ---');
            core.info(
              `METRIC deployment_total{service="${service}",env="${envName}",from="${previousTag || ''}",to="${currentTag}",rollback="${rollback}"} 1`
            );

            if (!previousTag) {
              core.info('No previous tag; skipping lead-time calculation.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const prevRef = previousTag;
            const currRef = currentTag;

            core.info(`Fetching commits between ${prevRef}...${currRef}`);

            const compare = await github.rest.repos.compareCommitsWithBasehead({
              owner,
              repo,
              basehead: `${prevRef}...${currRef}`,
            });

            const commits = compare.data.commits ?? [];
            core.info(`Found ${commits.length} commits in diff.`);

            const deployTime = new Date();
            const leadTimesMerge = [];
            const leadTimesFirstCommit = [];
            const seenPrs = new Set();

            for (const commit of commits) {
              const sha = commit.sha;

              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha: sha,
              });

              for (const pr of prs.data) {
                if (!pr.merged_at) continue;
                if (seenPrs.has(pr.number)) continue;
                seenPrs.add(pr.number);

                const mergedAt = new Date(pr.merged_at);
                const leadTimeMergeSeconds = Math.round(
                  (deployTime.getTime() - mergedAt.getTime()) / 1000
                );
                leadTimesMerge.push(leadTimeMergeSeconds);

                // ðŸ” NEW: first-commit-in-PR â†’ deploy lead time
                const prCommits = await github.rest.pulls.listCommits({
                  owner,
                  repo,
                  pull_number: pr.number,
                  per_page: 100,
                });

                let earliestCommitTime = null;
                for (const c of prCommits.data) {
                  const authorDate = c.commit?.author?.date;
                  const committerDate = c.commit?.committer?.date;
                  const candidate = authorDate || committerDate;
                  if (!candidate) continue;

                  const t = new Date(candidate);
                  if (!earliestCommitTime || t < earliestCommitTime) {
                    earliestCommitTime = t;
                  }
                }

                let leadTimeFirstCommitSeconds = null;
                if (earliestCommitTime) {
                  leadTimeFirstCommitSeconds = Math.round(
                    (deployTime.getTime() - earliestCommitTime.getTime()) / 1000
                  );
                  leadTimesFirstCommit.push(leadTimeFirstCommitSeconds);
                }

                core.info(
                  `PR #${pr.number}: merged_at=${pr.merged_at} ` +
                  `â†’ merge_lead_time=${leadTimeMergeSeconds}s` +
                  (leadTimeFirstCommitSeconds != null
                    ? `, first_commit_lead_time=${leadTimeFirstCommitSeconds}s`
                    : '')
                );

                // Per-PR metrics
                core.info(
                  `METRIC deployment_lead_time_seconds{service="${service}",env="${envName}",pr="${pr.number}",type="merge_to_deploy"} ${leadTimeMergeSeconds}`
                );
                if (leadTimeFirstCommitSeconds != null) {
                  core.info(
                    `METRIC deployment_lead_time_seconds{service="${service}",env="${envName}",pr="${pr.number}",type="first_commit_to_deploy"} ${leadTimeFirstCommitSeconds}`
                  );
                }
              }
            }

            if (leadTimesMerge.length === 0) {
              core.info('No PRs with merged_at timestamps; no lead time metrics.');
              return;
            }

            function summaryStats(arr) {
              arr.sort((a, b) => a - b);
              const p50 = arr[Math.floor(0.5 * (arr.length - 1))];
              const p90 = arr[Math.floor(0.9 * (arr.length - 1))];
              const max = arr[arr.length - 1];
              return { p50, p90, max };
            }

            const mergeStats = summaryStats(leadTimesMerge);
            core.info('--- Lead time (PR merge â†’ deploy) summary ---');
            core.info(`p50=${mergeStats.p50}, p90=${mergeStats.p90}, max=${mergeStats.max}`);
            core.info(
              `METRIC deployment_lead_time_summary_seconds{service="${service}",env="${envName}",type="merge_to_deploy",stat="p50"} ${mergeStats.p50}`
            );
            core.info(
              `METRIC deployment_lead_time_summary_seconds{service="${service}",env="${envName}",type="merge_to_deploy",stat="p90"} ${mergeStats.p90}`
            );
            core.info(
              `METRIC deployment_lead_time_summary_seconds{service="${service}",env="${envName}",type="merge_to_deploy",stat="max"} ${mergeStats.max}`
            );

            if (leadTimesFirstCommit.length > 0) {
              const firstStats = summaryStats(leadTimesFirstCommit);
              core.info('--- Lead time (first commit in PR â†’ deploy) summary ---');
              core.info(`p50=${firstStats.p50}, p90=${firstStats.p90}, max=${firstStats.max}`);
              core.info(
                `METRIC deployment_lead_time_summary_seconds{service="${service}",env="${envName}",type="first_commit_to_deploy",stat="p50"} ${firstStats.p50}`
              );
              core.info(
                `METRIC deployment_lead_time_summary_seconds{service="${service}",env="${envName}",type="first_commit_to_deploy",stat="p90"} ${firstStats.p90}`
              );
              core.info(
                `METRIC deployment_lead_time_summary_seconds{service="${service}",env="${envName}",type="first_commit_to_deploy",stat="max"} ${firstStats.max}`
              );
            } else {
              core.info('No commit timestamps found for PRs to compute first-commit lead time.');
            }
